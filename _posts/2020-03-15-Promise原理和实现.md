---
layout: post
title: Promise原理和实现
subtitle: JavaScript系列
date: 2020-03-15
author: Jalever
header-img: img/post-bg-js-version.jpg
catalog: true
tags:
  - JavaScript
---

- [原理](#%e5%8e%9f%e7%90%86)
- [实现](#%e5%ae%9e%e7%8e%b0)
    - [简易版](#%e7%ae%80%e6%98%93%e7%89%88)
    - [简易的链式调用](#%e7%ae%80%e6%98%93%e7%9a%84%e9%93%be%e5%bc%8f%e8%b0%83%e7%94%a8)
    - [延时机制](#%e5%bb%b6%e6%97%b6%e6%9c%ba%e5%88%b6)
    - [状态机制](#%e7%8a%b6%e6%80%81%e6%9c%ba%e5%88%b6)
    - [链式调用](#%e9%93%be%e5%bc%8f%e8%b0%83%e7%94%a8)
    - [错误处理](#%e9%94%99%e8%af%af%e5%a4%84%e7%90%86)
    - [异常处理](#%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86)
    - [finally实现](#finally%e5%ae%9e%e7%8e%b0)

## 原理

内部封装了回调函数，使用上一直通过 then 方法链式调用

本文 Promise 源码按照 Promise/A+规范来编写的

## 实现

#### 简易版

```js
function onPromise(fn) {
  let value = null,
    callbacks = [];

  this.then = function(onFulfilled) {
    this.callbacks.push(onFulfilled);
  };

  function resolve(value) {
    this.callbacks.forEach(fn => fn(value));
  }

  fn(resolve);
}

//Promise应用
let p = new onPromise(resolve => {
  setTimeout(() => {
    console.log("done");
    resolve("5秒");
  }, 5000);
}).then(tip => {
  console.log(tip);
});
```

上述代码很简单，大致的逻辑是这样的：

- 调用 `then` 方法，将想要在 `onPromise` 异步操作成功时执行的 `onFulfilled` 放入`callbacks`队列，其实也就是注册回调函数
- 创建 `onPromise` 实例时传入的函数会被赋予一个函数类型的参数，即 `resolve`，它接收一个参数 `value`，代表异步操作返回的结果，当异步操作执行成功后，会调用`resolve`方法，这时候其实真正执行的操作是将 `callbacks` 队列中的回调一一执行

首先 `new onPromise` 时，传给 `onPromise` 的函数设置定时器模拟异步的场景，接着调用 `onPromise` 对象的 `then` 方法注册异步操作完成后的 `onFulfilled`，最后当异步操作完成时，调用 `resolve(value)`， 执行 `then` 方法注册的 `onFulfilled`。

`then` 方法注册的 `onFulfilled` 是存在一个数组中，可见 `then` 方法可以调用多次，注册的多个`onFulfilled` 会在异步操作完成后根据添加的顺序依次执行。如下：

```js
//then 的说明
let p = new onPromise(resolve => {
  setTimeout(() => {
    console.log("done");
    resolve("5秒");
  }, 5000);
});

p.then(tip => {
  console.log("then1", tip);
});

p.then(tip => {
  console.log("then2", tip);
});
```

#### 简易的链式调用

上例中，要先定义一个变量 `p` ，然后 `p.then` 两次。而规范中要求，`then` 方法应该能够链式调用。实现也简单，只需要在 `then` 中 `return this` 即可。如下所示：

```js
function onPromise(fn) {
  let value = null,
    callbacks = [];

  this.then = function(onFulfilled) {
    this.callbacks.push(onFulfilled);
    return this;
  };

  function resolve(value) {
    this.callbacks.forEach(fn => fn(value));
  }

  fn(resolve);
}
```

#### 延时机制

上面 `Promise` 的实现存在一个问题：如果在 `then` 方法注册 `onFulfilled` 之前，`resolve` 就执行了，`onFulfilled` 就不会执行到了。比如上面的例子中我们把 `setTimout` 去掉：

```js
//同步执行了resolve
let p = new onPromise(resolve => {
  console.log("同步执行");
  resolve("同步执行");
})
  .then(tip => {
    console.log("then1", tip);
  })
  .then(tip => {
    console.log("then2", tip);
  });

//同步执行
```

执行结果显示，只有 "同步执行" 被打印了出来，后面的 "then1" 和 "then2" 均没有打印出来。再回去看下 `Promise` 的源码，也很好理解，`resolve` 执行时，callbacks 还是空数组，还没有`onFulfilled` 注册上来

这显然是不允许的，`Promises/A+`规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。因此要加入一些处理，保证在 `resolve` 执行之前，`then` 方法已经注册完所有的回调

```js
function onPromise(fn) {
  let value = null,
    callbacks = [];

  this.then = function(onFulfilled) {
    this.callbacks.push(onFulfilled);
    return this;
  };

  function resolve(value) {
    setTimeout(() => {
      this.callbacks.forEach(fn => fn(value));
    }, 0);
  }

  fn(resolve);
}
```

在 `resolve` 中增加定时器，通过 `setTimeout` 机制，将 `resolve` 中执行回调的逻辑放置到`JS`任务队列末尾，以保证在 `resolve` 执行时，`then`方法的 `onFulfilled` 已经注册完成

#### 状态机制

这样依然存在问题，在 `resolve` 执行后，再通过 `then` 注册上来的 `onFulfilled` 都没有机会执行了。如下所示，我们加了延迟后，`then1` 和 `then2` 可以打印出来了，但下例中的 `then3` 依然打印不出来。所以我们需要增加状态，并且保存 `resolve` 的值

```js
let p = new onPromise(resolve => {
  console.log("同步执行");
  resolve("同步执行");
})
  .then(tip => {
    console.log("then1", tip);
  })
  .then(tip => {
    console.log("then2", tip);
  });

setTimeout(() => {
  p.then(tip => {
    console.log("then3", tip);
  });
});
```

为了解决上面的问题，我们引入了状态机制，也就是大家熟知的 `pending`、`fulfilled`、`rejected`

`Promises/A+` 规范中明确规定了，`pending`可以转化为 `fulfilled` 或 `rejected` 并且只能转化一次，也就是说如果 `pending` 转化到 `fulfilled` 状态，那么就不能再转化到 `rejected`。并且 `fulfilled` 和 `rejected` 状态只能由 `pending` 转化而来，两者之间不能互相转换。

```js
function onPromise(fn) {
  let value = null,
    state = "pending",
    callbacks = [];

  this.then = function(onFulfilled) {
    if (state === "pending") {
      this.callbacks.push(onFulfilled);
      return this;
    }

    onFulfilled(value);
    return this;
  };

  function resolve(newValue) {
    value = newValue;
    state = "fulfilled";

    setTimeout(function() {
      this.callbacks.forEach(fn => fn(value));
    }, 0);
  }

  fn(resolve);
}
```

#### 链式调用

上文中的链式调用的实现只是在 `then` 中 `return` 了 `this`，因为是同一个实例，调用再多次 `then` 也只能返回相同的一个结果. 虽然实现的`onPromise` 实例可以多次调用 `then` 方法，但因为是同一个实例，调用再多次 `then` 也只能返回相同的一个结果，通常我们希望的链式调用是这样的：

```js
getUserId("some_url")
  .then(function(id) {
    //do something
    return getNameById(id);
  })
  .then(function(name) {
    //do something
    return getCourseByName(name);
  })
  .then(function(course) {
    //do something
    return getCourseDetailByCourse(course);
  })
  .then(function(courseDetail) {
    //do something
  });
```

每个 `then` 注册的 `onFulfilled` 都返回了不同的结果，层层递进，很明显在 `then` 方法中 `return this` 不能达到这个效果。引入真正的链式调用，`then` 返回的一定是一个新的`onPromise`实例

```js
function onPromise(fn) {
  let value = null,
    state = "pending",
    callbacks = [];

  this.then = function(onFulfilled) {
    return new onPromise(resolve =>
      onHandle({
        onFulfilled: onFulfilled || null,
        resolve
      })
    );
  };

  function onHandle(cb) {
    if (state === "pending") {
      this.callbacks.push(cb);
      return;
    }

    if (!cb.onFulfilled) {
      cb.resolve(value);
      return;
    }

    let ret = cb.onFulfilled(value);
    cb.resolve(ret);
  }

  function resolve(newValue) {
    value = newValue;
    state = "fulfilled";

    setTimeout(function() {
      this.callbacks.forEach(fn => onHandle(fn));
    }, 0);
  }

  fn(resolve);
}
```

由上面的实现，我们可以看到：

- `then` 方法中，创建并返回了新的 `onPromise` 实例，这是串行`onPromise`的基础，是实现真正链式调用的根本
- `then` 方法传入的形参 `onFulfilled` 以及创建新 `onPromise` 实例时传入的 `resolve` 放在一起，被 push 到当前 `onPromise` 的 `callbacks` 队列中，这是衔接当前 `onPromise` 和后邻 `Promise` 的关键所在
- 根据规范，`onFulfilled` 是可以为空的，为空时不调用 `onFulfilled`

刚才一下演示的都是 `onFulfilled` 返回值是 `value` 的情况，如果是一个 `onPromise` 呢？是不是就可以通过 `onFulfilled`，由使用 `onPromise` 的开发者决定后续 `onPromise` 的状态。

于是在 `_resolve` 中增加对前一个 `onPromise onFulfilled` 返回值的判断

```js
function onPromise(fn) {
  let value = null,
    state = "pending",
    callbacks = [];

  this.then = function(onFulfilled) {
    return new onPromise(resolve => {
      onHandle({
        onFulfilled: onFulfilled || null,
        resolve
      });
    });
  };

  function onHandle(cb) {
    if (state === "pending") {
      callbacks.push(cb);
      return;
    }

    if (!cb.onFulfilled) {
      cb.resolve(value);
      return;
    }

    let ret = cb.onFulfilled(value);
    cb.resolve(ret);
  }

  function resolve(newValue) {
    if (
      (newValue && typeof newValue === "object") ||
      typeof newValue === "function"
    ) {
      const { then } = newValue;
      then.call(newValue, resolve);
    }

    value = newValue;
    state = "fulfilled";

    setTimeout(function() {
      this.callbacks.forEach(fn => fn(value));
    }, 0);
  }

  fn(resolve);
}
```

它是对 `resolve` 中的值作了一个特殊的判断，判断 `resolve` 的值是否为`onPromise`实例，如果是 `onPromise` 实例，那么就把当前 `onPromise` 实例的状态改变接口重新注册到 `resolve` 的值对应的 `Promise` 的 `onFulfilled` 中，也就是说当前 `onPromise` 实例的状态要依赖`resolve` 的值的 `onPromise` 实例的状态

#### 错误处理
```js
function onPromise(fn) {
  let value = null,
    state = "pending",
    callbacks = [];

  this.then = function(onFulfilled, onRejected) {
    return new onPromise((resolve, reject) => {
      onHandle({
        onFulfilled: onFulfilled || null,
        onRejected: onRejected || null,
        resolve,
        reject
      });
    });
  };

  function onHandle(callback) {
    if (state === "pending") {
      callbacks.push(callback);
      return;
    }

    let cb = state === "fulfilled" ? callback.onFulfilled : callback.onRejected,
        ret;

    if (cb === null) {
      let cb = state === "fulfilled" ? callback.resolve : callback.reject;
      cb(value);
      return;
    }

    ret = cb(value);
    callback.resolve(ret);
  }

  function resolve(newValue) {
    if (
      (newValue && typeof newValue === "object") ||
      typeof newValue === "function"
    ) {
      const { then } = newValue;
      then.call(newValue, resolve, reject);
    }

    value = newValue;
    state = "fulfilled";
    onExecute();
  }

  
  function reject(reason) {
    value = reason;
    state = "rejected";
    onExecute();
  }

  function onExecute() {
    setTimeout(function() {
      this.callbacks.forEach(cb => onHandle(cb));
    }, 0);
  }

  fn(resolve);
}
```


#### 异常处理
刚刚介绍了错误处理，是指在 `Promise` 的构造函数中发现的错误，并通过 `reject` 通知的。如果在执行 `onFulfilled` 或者 `onRejected` 时，出现了异常，该如何处理呢？对于这类异常，处理也很简单，可以使用 `try-catch` 捕获错误，然后将相应的 `Promise` 状态设置为 `rejected` 状态

```js
function onPromise(fn) {
  let value = null,
    state = "pending",
    callbacks = [];

  this.then = function(onFulfilled, onRejected) {
    return new onPromise((resolve, reject) => {
      onHandle({
        onFulfilled: onFulfilled || null,
        onRejected: onRejected || null,
        resolve,
        reject
      });
    });
  };

  function onHandle(callback) {
    if (state === "pending") {
      callbacks.push(callback);
      return;
    }

    let cb = state === "fulfilled" ? callback.onFulfilled : callback.onRejected,
      ret;

    if (cb === null) {
      let cb = state === "fulfilled" ? callback.resolve : callback.reject;
      cb(value);
      return;
    }

    try {
      ret = cb(value);
      callback.resolve(ret);
    } catch (error) {
      callback.reject(error);
    }
  }

  function resolve(newValue) {
    if (
      (newValue && typeof newValue === "object") ||
      typeof newValue === "function"
    ) {
      const { then } = newValue;
      then.call(newValue, resolve, reject);
    }

    value = newValue;
    state = "fulfilled";
    onExecute();
  }

  function reject(reason) {
    value = reason;
    state = "rejected";
    onExecute();
  }

  function onExecute() {
    setTimeout(function() {
      this.callbacks.forEach(cb => onHandle(cb));
    }, 0);
  }

  fn(resolve);
}
```

#### finally实现
在实际应用的时候，我们很容易会碰到这样的场景，不管`Promise`最后的状态如何，都要执行某些操作(onDone). 例如服务器使用 `Promise` 处理请求，然后使用`finally`方法关掉服务器
```js

function onPromise(fn) {
  let value = null,
    state = "pending",
    callbacks = [];

  this.then = function(onFulfilled, onRejected) {
    return new onPromise((resolve, reject) => {
      onHandle({
        onFulfilled: onFulfilled || null,
        onRejected: onRejected || null,
        resolve,
        reject
      });
    });
  };

  this.catch = function(onError) {
    return this.then(null, onError);
  };

  this.finally = function(onDone) {
    if(typeof onDone !== 'function') return this.then();

    let p = this;
    return this.then(
      value => p.resolve(onDone()).then(() => value),
      reason => p.resolve(onDone()).then(() => {
        throw reason;
      })
    );
  };

  function onHandle(callback) {
    if (state === "pending") {
      callbacks.push(callback);
      return;
    }

    let cb = state === "fulfilled" ? callback.onFulfilled : callback.onRejected,
      ret;

    if (cb === null) {
      let cb = state === "fulfilled" ? callback.resolve : callback.reject;
      cb(value);
      return;
    }

    try {
      ret = cb(value);
      callback.resolve(ret);
    } catch (error) {
      callback.reject(error);
    }
  }

  function resolve(newValue) {
    if (
      (newValue && typeof newValue === "object") ||
      typeof newValue === "function"
    ) {
      const { then } = newValue;
      then.call(newValue, resolve, reject);
    }

    value = newValue;
    state = "fulfilled";
    onExecute();
  }

  function reject(reason) {
    value = reason;
    state = "rejected";
    onExecute();
  }

  function onExecute() {
    setTimeout(function() {
      this.callbacks.forEach(cb => onHandle(cb));
    }, 0);
  }

  fn(resolve);
}
```