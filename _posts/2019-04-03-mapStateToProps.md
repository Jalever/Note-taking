---
layout: post
title: mapStateToProps
subtitle: React Redux学习笔记系列
date: 2019-04-03
author: Jalever
header-img: img/post_2019_react_bg_shadow.jpg
catalog: true
tags:
  - React
  - React Redux
---

## Table of Contents

- [Table of Contents](#table-of-contents)
- [Preface](#preface)
- [Defining `mapStateToProps`](#defining-mapstatetoprops)
- [Arguments](#arguments)
- [Return](#return)
- [Usage Guidelines](#usage-guidelines)
    - [Let `mapStateToProps` Reshape the Data from the Store](#let-mapstatetoprops-reshape-the-data-from-the-store)
    - [Use Selector Functions to Extract and Transform Data](#use-selector-functions-to-extract-and-transform-data)
    - [`mapStateToProps` Functions Should Be Fast](#mapstatetoprops-functions-should-be-fast)
    - [`mapStateToProps` Functions Should Be Pure and Synchronous](#mapstatetoprops-functions-should-be-pure-and-synchronous)
- [`mapStateToProps` and Performance](#mapstatetoprops-and-performance)
    - [Return Values Determine If Your Component Re-Renders](#return-values-determine-if-your-component-re-renders)
    - [Only Return New Object References If Needed](#only-return-new-object-references-if-needed)
    - [Only Perform Expensive Operations When Data Changes](#only-perform-expensive-operations-when-data-changes)
- [Behavior and Gotchas](#behavior-and-gotchas)
    - [`mapStateToProps` Will Not Run if the `Store` State is the Same](#mapstatetoprops-will-not-run-if-the-store-state-is-the-same)
    - [The Number of Declared Arguments Affects Behavior](#the-number-of-declared-arguments-affects-behavior)

## Preface

The first argument passed in to `connect`<br>
`mapStateToProps` is used for **_selecting the part of the data from the store_** that the connected component needs.<br>
It’s frequently referred to as just `mapState` for short

- It is called every time the store state changes.
- It receives the entire store state, and should return an object of data this component needs.
  <br>

## Defining `mapStateToProps`

`mapStateToProps` should be defined as a function:

```javascript
function mapStateToProps(state, ownProps)
```

It should take a **_first argument_** called `state`, optionally a **_second argument_** called `ownProps`, and return a **_plain object_** containing the data that the connected component needs.<br>

This function should be passed as the first argument to `connect`, and will be **_called every time_** when the `Redux` store state changes. If you <ins>do not</ins> wish to subscribe to the store, pass `null` or `undefined` to connect in place of `mapStateToProps`.<br>

It does not matter if a `mapStateToProps` function is written using the **_function_** keyword (`function mapState(state) { }` ) or as an **_arrow function_** (`const mapState = (state) => { }` )- it will work the same either way.

## Arguments

1. state<br>
   The first argument to a `mapStateToProps` function is the **_entire `Redux` store state_** (the same value returned by a call to `store.getState()`)

```javascript
// TodoList.js

function mapStateToProps(state) {
  const { todos } = state;
  return { todoList: todos.allIds };
}

export default connect(mapStateToProps)(TodoList);
```

2. ownProps (optional)<br>
   if your component needs the data from its own `props` to retrieve data from the store.<br>
   This argument will contain <ins>all of the props</ins> **_given to the wrapper component_** that <ins>was generated by `connect`</ins>.<br>

## Return

Your `mapStateToProps` function should return a plain object that contains the data the component needs:

- Each field in the object will become a prop for your actual component
- The values in the fields will be used to determine if your component needs to re-render

```javascript
function mapStateToProps(state) {
  return {
    a: 42,
    todos: state.todos,
    filter: state.visibilityFilter
  };
}

// component will receive: props.a, props.todos, and props.filter
```

## Usage Guidelines

#### Let `mapStateToProps` Reshape the Data from the Store

They have the responsibility of "re-shaping" store data as needed for that component.<br>
This may include **_returning a value as a specific prop name_**, <ins>combining pieces of data from different parts of the state tree</ins>, and **_transforming the store data in different ways_**.<br>

#### Use Selector Functions to Extract and Transform Data

We encourage the use of **_selector functions_** to help encapsulate the process of extracting values from specific locations in the state tree.<br>

#### `mapStateToProps` Functions Should Be Fast

Whenever the store changes, all of the `mapStateToProps` functions of all of the connected components will run. <br>

#### `mapStateToProps` Functions Should Be Pure and Synchronous

It should simply take `state` (and `ownProps`) as arguments, and return the data the component needs as `props`.<br>

## `mapStateToProps` and Performance

#### Return Values Determine If Your Component Re-Renders

`React Redux` internally implements the `shouldComponentUpdate` method such that the wrapper component re-renders precisely when the data your component needs has changed.<br>
By default, `React Redux` decides whether the contents of the object returned from `mapStateToProps` are different using `===` comparison (a `shallow equality` check) on each fields of the returned object.

#### Only Return New Object References If Needed

Many common operations result in new object or array references being created:

- Creating new arrays with `someArray.map()` or `someArray.filter()`
- Merging arrays with `array.concat`
- Selecting portion of an array with `array.slice`
- Copying values with `Object.assign`
- Copying values with the spread operator `{ ...oldState, ...newData }`

#### Only Perform Expensive Operations When Data Changes

In order for your `mapStateToProps` function to be as fast as possible, you should only re-run these complex transformations when the relevant data has changed.
There are a few ways to approach this:

- Some transformations could be calculated in an `action creator` or `reducer`, and the transformed data could be kept in the store
- Transformations can also be done in a component's `render()` method
- If the transformation does need to be done in a `mapStateToProps` function, then we recommend using `memoized selector functions` to ensure the transformation is only run when the input values have changed.

## Behavior and Gotchas

#### `mapStateToProps` Will Not Run if the `Store` State is the Same

The wrapper component generated by connect subscribes to the `Redux` store.<br>
Every time an action is dispatched, it calls `store.getState()` and checks to see if `lastState === currentState`. <br>
If the two state values are identical by reference, then it will not re-run your `mapStateToProps` function, because it assumes that the rest of the store state hasn't changed either.<br>
If none of the slice reducers returned a new value, then combineReducers returns the old state object instead of a new one.<br>
This means that mutation in a reducer can lead to the root state object not being updated, and thus the `UI` won't re-render.

#### The Number of Declared Arguments Affects Behavior

With just `(state)`, the function runs whenever the root store state object is different.<br>
With `(state, ownProps)`, it runs any time the `store state` is different and ALSO whenever the `wrapper props` have changed.

```javascript
function mapStateToProps(state) {
  console.log(state); // state
  console.log(arguments[1]); // undefined
}
const mapStateToProps = (state, ownProps = {}) => {
  console.log(state); // state
  console.log(ownProps); // undefined
};
function mapStateToProps(state, ownProps) {
  console.log(state); // state
  console.log(ownProps); // ownProps
}

function mapStateToProps() {
  console.log(arguments[0]); // state
  console.log(arguments[1]); // ownProps
}

function mapStateToProps(...args) {
  console.log(args[0]); // state
  console.log(args[1]); // ownProps
}
```
