---
layout: post
title: Accessing the Store
subtitle: React Redux学习笔记系列
date: 2019-04-07
author: Jalever
header-img: img/post_2019_react_bg_shadow.jpg
catalog: true
tags:
  - React
  - React Redux
---

## Table of Contents

- [Table of Contents](#table-of-contents)
- [Understanding Context Usage](#understanding-context-usage)
- [Providing Custom Context](#providing-custom-context)
- [Multiple Stores](#multiple-stores)
- [Using ReactReduxContext Directly](#using-reactreduxcontext-directly)

## Understanding Context Usage
Internally, `React Redux` uses `React`'s "context" feature to make the `Redux` store accessible to deeply nested connected components. <br>
As of `React Redux` version 6, this is normally handled by a single default context object instance generated by `React.createContext()`, called `ReactReduxContext`.<br>
`React Redux`'s `<Provider>` component uses `<ReactReduxContext.Provider>` to put the `Redux` store and the current store ***state*** into context, and ***connect*** uses `<ReactReduxContext.Consumer>` to read those values and handle updates.<br>

## Providing Custom Context
Instead of using the <ins>default context instance</ins> from `React Redux`, you may supply your own <ins>custom context instance</ins>.<br>
```javascript
<Provider context={MyContext} store={store}>
  <App />
</Provider>
```
If you supply a <ins>custom context</ins>, `React Redux` will use that context instance instead of the one it creates and exports by default.<br>
After you’ve supplied the <ins>custom context</ins> to `<Provider />`, you will need to supply this context instance to all of your connected components that are expected to connect to the same store:
```javascript
// You can pass the context as an option to connect
export default connect(
  mapState,
  mapDispatch,
  null,
  { context: MyContext }
)(MyComponent);

// or, call connect as normal to start
const ConnectedComponent = connect(
  mapState,
  mapDispatch
)(MyComponent);

// Later, pass the custom context as a prop to the connected component
<ConnectedComponent context={MyContext} />
```

## Multiple Stores
`Redux` was designed to use a single store
```javascript
// a naive example
const ContextA = React.createContext();
const ContextB = React.createContext();

// assuming reducerA and reducerB are proper reducer functions
const storeA = createStore(reducerA);
const storeB = createStore(reducerB);

// supply the context instances to Provider
function App() {
  return (
    <Provider store={storeA} context={ContextA} />
      <Provider store={storeB} context={ContextB}>
        <RootModule />
      </Provider>
    </Provider>
  );
}

// fetch the corresponding store with connected components
// you need to use the correct context
connect(mapStateA, null, null, { context: ContextA })(MyComponentA)

// You may also pass the alternate context instance directly to the connected component instead
<ConnectedMyComponentA context={ContextA} />

// it is possible to chain connect()
// in this case MyComponent will receive merged props from both stores
compose(
  connect(mapStateA, null, null, { context: ContextA }),
  connect(mapStateB, null, null, { context: ContextB })
)(MyComponent);
```

## Using ReactReduxContext Directly
In rare cases, you may need to access the `Redux` store directly in your own components.<br>
This can be done by rendering the appropriate context consumer yourself, and accessing the store field out of the context value.
```javascript
import { ReactReduxContext } from 'react-redux'

// in your connected component
function MyConnectedComponent() {
  return (
    <ReactReduxContext.Consumer>
      {({ store }) => {
        // do something useful with the store, like passing it to a child
        // component where it can be used in lifecycle methods
      }}
    </ReactReduxContext.Consumer>
  );
}

```



